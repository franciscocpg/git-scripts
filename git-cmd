#!/bin/bash

# varíaveis
CMD="$1"
CMD_ARGS="$2"
GIT_REPO_PATH="$3"
CLEAR="$4"
PRINT_PATH_ONLY="$5"
BEFORE_EXEC="$6"
PRINT_CMD="$7"
AFTER_EXEC="$8"
FORCE_PUSH="false"


if [[ -z "$PRINT_CMD" ]]; then
  PRINT_CMD="true"
fi
OUT=""
if [[ "$CLEAR" != "false" ]]; then
  clear
fi
RETURN_STATUS="0"
# Verifica se as configurações estão iniciadas
git-init-config

# Corrige o arquivo project.properties que fica mudando de acordo com o ambiente
# ATENÇÃO. Ao atualizar o netbeans, verificar se não é necessário rever o DEFAULT_VALUE
normalizeProjectProperties() {
	DEFAULT_VALUE='${j2ee.server.middleware}/mq/lib/jaxm-api.jar\:${j2ee.server.home}/modules/endorsed/javax.annotation-api.jar\:${j2ee.server.home}/modules/endorsed/jaxb-api-osgi.jar\:${j2ee.server.home}/modules/endorsed/webservices-api-osgi.jar\:${j2ee.server.home}/modules/javax.mail.jar\:${j2ee.server.home}/modules/javax.websocket-api.jar\:${j2ee.server.home}/modules/javax.batch-api.jar\:${j2ee.server.home}/modules/javax.security.auth.message-api.jar\:${j2ee.server.home}/modules/javax.json.jar\:${j2ee.server.home}/modules/javax.enterprise.concurrent-api.jar\:${j2ee.server.home}/modules/javax.xml.registry-api.jar\:${j2ee.server.home}/modules/javax.enterprise.concurrent.jar\:${j2ee.server.home}/modules/javax.management.j2ee-api.jar\:${j2ee.server.home}/modules/jaxb-osgi.jar\:${j2ee.server.home}/modules/javax.interceptor-api.jar\:${j2ee.server.home}/modules/weld-osgi-bundle.jar\:${j2ee.server.home}/modules/javax.resource-api.jar\:${j2ee.server.home}/modules/javax.ejb-api.jar\:${j2ee.server.home}/modules/javax.faces.jar\:${j2ee.server.home}/modules/javax.jms-api.jar\:${j2ee.server.home}/modules/javax.security.jacc-api.jar\:${j2ee.server.home}/modules/javax.servlet.jsp.jstl.jar\:${j2ee.server.home}/modules/javax.servlet-api.jar\:${j2ee.server.home}/modules/javax.enterprise.deploy-api.jar\:${j2ee.server.home}/modules/javax.xml.rpc-api.jar\:${j2ee.server.home}/modules/javax.el.jar\:${j2ee.server.home}/modules/bean-validator.jar\:${j2ee.server.home}/modules/javax.persistence.jar\:${j2ee.server.home}/modules/javax.transaction-api.jar\:${j2ee.server.home}/modules/javax.inject.jar\:${j2ee.server.home}/modules/webservices-osgi.jar\:${j2ee.server.home}/modules/javax.ws.rs-api.jar\:${j2ee.server.home}/modules/javax.servlet.jsp.jstl-api.jar\:${j2ee.server.home}/modules/javax.servlet.jsp.jar\:${j2ee.server.home}/modules/javax.servlet.jsp-api.jar'
	KEY="j2ee.platform.classpath"
	for file in $(find . -name "project.properties"); do
		OLD_VALUE=$(cat "$file" | grep $KEY)
		if [[ -n "$OLD_VALUE" ]]; then
			# Tranforma em array 
			arr=$(echo $OLD_VALUE | tr ":" " ")
			arr=($arr)
			array_len="${#arr[@]}"
			if [[ "$array_len" = 35 ]]; then
				VALUE=${OLD_VALUE/'j2ee.platform.classpath='/}
				LAST="${VALUE:len - 1}"
				ascii=`printf "%d" "'$LAST"`
				# Exclui caracteres que não são letras(CR, LF, etc)
				if [[ "$ascii" -lt 65 ]]; then
					len="${#VALUE}"
					VALUE="${VALUE:0:len - 1}"
				fi
				if [[ "$VALUE" != "$DEFAULT_VALUE" ]]; then
					NEW_VALUE="$KEY=$DEFAULT_VALUE"
					CONTENTS=$(cat "$file")
					CONTENTS=${CONTENTS/"$OLD_VALUE"/$NEW_VALUE}
					# echo -e "$CONTENTS"
					echo "$CONTENTS" > $file
				fi
			fi
		fi
	done
}

printCmd() {
  if [[ "$PRINT_CMD" = "true" ]]; then
    echo -e "\n=========================================="
    echo "$CMD $CMD_ARGS $path"
  fi
}

gitCmdExec() {
  if [[ "$CMD" != "test-commit" ]]; then
    local print="$1"
    if [[ "$print" = "true" ]]; then
      printCmd
    fi
    if [[ "$CMD" = "status" || "$CMD" = "add" ]]; then
    	normalizeProjectProperties
    fi
    if [[ -f "$BEFORE_EXEC" ]]; then
      echo "Executando $BEFORE_EXEC"
      ./$BEFORE_EXEC
    fi
    if [ "$CMD_ARGS" != "" ]
    then
      args=( "$CMD_ARGS" )
      if [[ "$CMD_ARGS" = "-m"* ]]
      then
        git $CMD "${args[@]}"
      else 
        git $CMD ${args[@]}
      fi
    else
      if [[ "$CMD" = "create-mr" ]]; then
		gitlab-create-mr .
  	  else
  	    git $CMD
  	  fi
    fi
  fi
  RETURN_STATUS=$?
  if [[ "$RETURN_STATUS" -gt 1 ]]; then
  	echo "Saida: $RETURN_STATUS"
  	exit $RETURN_STATUS
  fi
  if [[ "$RETURN_STATUS" = "0" && -f "$AFTER_EXEC" ]]; then
    ./$AFTER_EXEC
  fi
}

beforePush() {
  GIT_CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  GIT_REMOTE_REPO="origin"
  GIT_CURRENT_REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
  GIT_REMOTE_BRANCH="$GIT_REMOTE_REPO/$GIT_CURRENT_BRANCH"
  if [[ "$GIT_CURRENT_REMOTE_BRANCH" != "$GIT_REMOTE_BRANCH" ]]; then
    echo "Setando branch para $GIT_REMOTE_BRANCH"
    git push -u "$GIT_REMOTE_REPO" "$GIT_CURRENT_BRANCH"
    if [[ "$GIT_REPO_PATH" != "" ]]; then
    	exit $?
    fi
  fi
}

gitCmd() {
  local path="$1"
  if [[ -e "$path" ]]; then
	cd "$path"
	# É um repositório git
	if [[ -e ".git" || "$GIT_REPO_PATH" != "" ]]; then
		if [[ "$CMD" = "diff" && "$PRINT_PATH_ONLY" != "true" ]]; then
			# Diff imprime colorido
			outputCmd=$(gitCmdExec)
			if [[ -n "$outputCmd" ]]; then
			  OUT="$OUT$outputCmd"
			  printCmd
			  gitCmdExec
			fi
		else
			execGitCmd="true"
			if [[ "$CMD" = "push" && "$CMD_ARGS" != *"--delete"*  ]]; then
			  outputCmd=$(git status -s -b)
			  # Pega a primeira linha da saida
			  outputCmd=$(echo -e "$outputCmd" | sed -n 1p)
			  # Não executa o push se a saida não contém o caracter [
			  if [[ "$FORCE_PUSH" = "false" && "$outputCmd" != *"["* ]]
			  then
				execGitCmd="false"
			  fi
			fi
			if [[ "$CMD" = "test-commit" ]]; then
			  normalizeProjectProperties
			  outputCmd=$(git status -s -b)
			  # Pega a quantidade de linhas na saida
			  outputCmdLines=$(echo -e "$outputCmd" | wc -l)
			  # Não executa o commit se a saida tiver menos de 2 linhas
			  if [[ $outputCmdLines -lt 2 ]]
			  then
				execGitCmd="false"
			  fi
			fi
			if [[ "$execGitCmd" = "true" ]]; then
			  if [[ "$CMD" = "push" ]]; then
				beforePush
			  fi
			  # Só mostra status do que alterou
			  if [[ "$CMD" = "status" ]]; then
				outputCmd=$(gitCmdExec)
				if [[ "$outputCmd" != "## master...origin/master" ]]; then
				   if [[ "$PRINT_PATH_ONLY" = "true" ]]; then
					OUT="$OUT$path\n"
				  else
					OUT="$OUT$(printCmd)"
					OUT="$OUT$outputCmd"
				  fi
				fi
			  # Só mostra diferença do que tem diferença
			  elif [[ "$CMD" = "diff" ]]; then
				outputCmd=$(gitCmdExec)
				local status="$?"
				if [[ "$status" != "0" ]]; then
				  OUT="\nErro: $path$OUT"
				elif [[ -n "$outputCmd" ]]; then
				  if [[ "$PRINT_PATH_ONLY" = "true" ]]; then
					OUT="$OUT$path\n"
				  else
					OUT="$OUT$(printCmd)\n"
					OUT="$OUT$outputCmd"
				  fi
				fi
			  else
				OUT=" "
				gitCmdExec "true"
			  fi
			fi
		fi
	else
		echo "Não é um repositório git: $path"
	fi
	cd ..
  fi
}

# execução programa
if [[ "$CMD" = "force-push"  ]]; then
	CMD="push"
	FORCE_PUSH="true"
fi
if [[ "$GIT_REPO_PATH" = "" ]]; then
  for dir in */; do
      gitCmd "$dir"
  done
else
  if [[ -d  "$GIT_REPO_PATH" ]]; then
    gitCmd "$GIT_REPO_PATH"
  elif [[ -f "$GIT_REPO_PATH" ]]; then
    while read -r gitRepoPath
    do
      gitCmd $gitRepoPath
    done < "$GIT_REPO_PATH"
  fi
  
fi

if [[ -z "$OUT" ]]; then
  echo "Nada a fazer"
  exit 1
else
  if [[ "$CMD" != "diff" || "$PRINT_PATH_ONLY" = "true" ]]; then
    echo -e "$OUT"
  fi
  exit $RETURN_STATUS
fi  

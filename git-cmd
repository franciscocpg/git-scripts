#!/bin/bash
CMD="$1"
CMD_ARGS="$2"
GIT_REPO_PATH="$3"
CLEAR="$4"
PRINT_PATH_ONLY="$5"
BEFORE_EXEC="$6"
PRINT_CMD="$7"
AFTER_EXEC="$8"
if [[ -z "$PRINT_CMD" ]]; then
  PRINT_CMD="true"
fi
OUT=""
if [[ "$CLEAR" != "false" ]]; then
  clear
fi
RETURN_STATUS="0"
# Verifica se as configurações estão iniciadas
git-init-config

printCmd() {
  if [[ "$PRINT_CMD" = "true" ]]; then
    echo -e "\n=========================================="
    echo "$CMD $CMD_ARGS $path"
  fi
}

gitCmdExec() {
  if [[ "$CMD" != "test-commit" ]]; then
    local print="$1"
    if [[ "$print" = "true" ]]; then
      printCmd
    fi
    if [[ -f "$BEFORE_EXEC" ]]; then
      echo "Executando $BEFORE_EXEC"
      ./$BEFORE_EXEC
    fi
    if [ "$CMD_ARGS" != "" ]
    then
      args=( "$CMD_ARGS" )
      if [[ "$CMD_ARGS" = "-m"* ]]
      then
        git $CMD "${args[@]}"
      else 
        git $CMD ${args[@]}
      fi
    else
      git $CMD
    fi
  fi
  RETURN_STATUS=$?
  if [[ "$RETURN_STATUS" = "0" && -f "$AFTER_EXEC" ]]; then
    ./$AFTER_EXEC
  fi
}

beforePush() {
  GIT_CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  GIT_REMOTE_REPO="origin"
}

afterPush() {
  GIT_CURRENT_REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
  GIT_REMOTE_BRANCH="$GIT_REMOTE_REPO/$GIT_CURRENT_BRANCH"
  if [[ "$GIT_CURRENT_REMOTE_BRANCH" != "$GIT_REMOTE_BRANCH" ]]; then
    echo "Setando branch para $GIT_REMOTE_BRANCH"
    git push -u "$GIT_REMOTE_REPO" "$GIT_CURRENT_BRANCH"
    exit 0
  fi
}

gitCmd() {
  local path="$1"
  cd "$path"
  if [[ "$CMD" = "diff" && "$PRINT_PATH_ONLY" != "true" ]]; then
    # Diff imprime colorido
    outputCmd=$(gitCmdExec)
    if [[ -n "$outputCmd" ]]; then
      OUT="$OUT$outputCmd"
      printCmd
      gitCmdExec
    fi
  else
    execGitCmd="true"
    if [[ "$CMD" = "push" && "$CMD_ARGS" != *"--delete"*  ]]; then
      outputCmd=$(git status -s -b)
      # Pega a primeira linha da saida
      outputCmd=$(echo -e "$outputCmd" | sed -n 1p)
      # Não executa o push se a saida não contém o caracter [
      if [[ "$outputCmd" != *"["* ]]
      then
        execGitCmd="false"
      fi
    fi
    if [[ "$CMD" = "test-commit" ]]; then
      outputCmd=$(git status -s -b)
      # Pega a quantidade de linhas na saida
      outputCmdLines=$(echo -e "$outputCmd" | wc -l)
      # Não executa o commit se a saida tiver menos de 2 linhas
      if [[ $outputCmdLines -lt 2 ]]
      then
        execGitCmd="false"
      fi
    fi
    if [[ "$execGitCmd" = "true" ]]; then
      if [[ "$CMD" = "push" ]]; then
        beforePush
      fi
      # Só mostra status do que alterou
      if [[ "$CMD" = "status" ]]; then
        outputCmd=$(gitCmdExec)
        if [[ "$outputCmd" != "## master...origin/master" ]]; then
           if [[ "$PRINT_PATH_ONLY" = "true" ]]; then
            OUT="$OUT$path\n"
          else
            OUT="$OUT$(printCmd)"
            OUT="$OUT$outputCmd"
          fi
        fi
      # Só mostra diferença do que tem diferença
      elif [[ "$CMD" = "diff" ]]; then
        outputCmd=$(gitCmdExec)
        local status="$?"
        if [[ "$status" != "0" ]]; then
          OUT="\nErro: $path$OUT"
        elif [[ -n "$outputCmd" ]]; then
          if [[ "$PRINT_PATH_ONLY" = "true" ]]; then
            OUT="$OUT$path\n"
          else
            OUT="$OUT$(printCmd)\n"
            OUT="$OUT$outputCmd"
          fi
        fi
      else
        OUT=" "
        gitCmdExec "true"
        if [[ "$CMD" = "push" ]]; then
          afterPush
        fi
      fi
    fi
  fi
  cd .. 
}

if [[ "$GIT_REPO_PATH" = "" ]]; then
  for dir in */; do
      gitCmd "$dir"
  done
else
  gitCmd "$GIT_REPO_PATH"
fi

if [[ -z "$OUT" ]]; then
  echo "Nada a fazer"
  exit 1
else
  if [[ "$CMD" != "diff" || "$PRINT_PATH_ONLY" = "true" ]]; then
    echo -e "$OUT"
  fi
  exit $RETURN_STATUS
fi  
